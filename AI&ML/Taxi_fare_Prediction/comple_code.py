# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J6heizR8r16gzQ8jC3AWi1AH4Ldt3RFi

DATA SET:
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from sklearn import neighbors
from prettytable import from_csv
cols=['fare_amount','pickup_datetime','pickup_longitude','pickup_latitude',
      'dropoff_longitude', 'dropoff_latitude','passenger_count']
data=pd.read_csv('train1.csv',nrows=100,usecols=cols)
data1=from_csv(open('train1.csv'))
print(data1)
print (data.columns)
print (data.shape)
data.head(5)
data.describe()

"""ANALYSIS OF  FAREAMOUNT:"""

data['fare_amount'][(data.fare_amount<0) | (data.fare_amount>=300)].count()
data.shape
data=data.drop(data[(data.fare_amount<0) | (data.fare_amount>=300)].index,axis=0)
data.fare_amount.isnull().sum()
data.shape
data.isnull().sum()

"""ANALYSIS OF LATITUDE AND LONGITUDE"""

lon_min=min(data.pickup_longitude.min(),data.dropoff_longitude.min())
lon_max=max(data.pickup_longitude.max(),data.dropoff_longitude.max())
print("Longitude minimum,Longitude minimum")
print(lon_min,',',lon_max)
lat_min=min(data.pickup_latitude.min(),data.dropoff_latitude.min())
lat_max=max(data.pickup_latitude.max(),data.dropoff_latitude.max())
print("Latitude minimum,Latitude maximum ")
print(lat_min,',',lat_max)
print(data.shape)
data[(data.pickup_latitude< lat_min) | (data.pickup_latitude>lat_max) ]
data.drop(data[(data.pickup_latitude< lat_min) | (data.pickup_latitude>lat_max)].index,axis=0,inplace=True)
data[(data.dropoff_latitude< lat_min) | (data.dropoff_latitude>lat_max)]
data.drop(data[(data.dropoff_latitude<lat_min) | (data.dropoff_latitude>lat_max)].index,axis=0,inplace=True)
print(data.shape)
data.pickup_longitude.abs().head()
data[(data.pickup_longitude<lon_min) | (data.pickup_longitude>lon_max)]
data.drop(data[(data.pickup_longitude<lon_min) | (data.pickup_longitude>lon_max)].index,axis=0,inplace=True)
data[(data.dropoff_longitude<lon_min) | (data.dropoff_longitude>lon_max)]
data[(data.dropoff_longitude<lon_min) | (data.dropoff_longitude>lon_max)]
print(data.shape)
data.isnull().sum()
data[data.dropoff_longitude.isnull()==True].head(1)
data.drop(data[data.dropoff_longitude.isnull()==True].index,axis=0,inplace=True)
data.isnull().sum()

"""ANALYSIS OF  PASSENGER COUNT"""

data['passenger_count'][data.passenger_count==0].count()
print(data.shape)
data.drop(data[data.passenger_count==0].index,axis=0,inplace=True)
print(data.shape)
print(data.shape)
data.drop(data[data.passenger_count>8].index,axis=0,inplace=True)
print(data.shape)

"""SPLITTING OF TIME"""

for i in  range(1,101):
  data['pickup_datetime'].head(i)
  data['pickup_datetime']=pd.to_datetime(data['pickup_datetime'], infer_datetime_format=True)
  data['pickup_datetime'].head(i)
  data['year'] = data['pickup_datetime'].dt.year
  data['Month'] = data['pickup_datetime'].dt.month
  data['Date'] = data['pickup_datetime'].dt.day
  data['Day of Week'] = data['pickup_datetime'].dt.dayofweek
  data['Hour'] = data['pickup_datetime'].dt.hour
  data['Minute'] = data['pickup_datetime'].dt.minute
print(data)
def final_convert(df):
        data['night_hour'] = np.where((data['Hour'] >= 20) |
                                (data['Hour'] <= 6) , 1, 0)
        data['peak_hour'] = np.where((data['Hour'] >= 16) &
                                (data['Hour'] <= 20) & 
                                (data['Day of Week'] >=0) &
                                (data['Day of Week'] <=4) , 1, 0)
        return data
data= final_convert(data)
print(data)
plt.bar(data['Date'],data['fare_amount'],label='date',color='yellow')
plt.xlabel('Date')
plt.ylabel('Fare')
plt.show()
plt.bar(data['Hour'],data['fare_amount'],label="Hour",align='center',color='g')
plt.xlabel('Hour')
plt.ylabel('Fare')
plt.show()
plt.bar(data['Day of Week'],data['fare_amount'],label="Day of Week",color='r')
plt.xlabel('Day of week')
plt.ylabel('Fare')
plt.show()

"""DISTANCE CALCULATION"""

from math import radians, cos, sin, asin, sqrt
def distance(a):
    lon1=a[0]
    lat1=a[1]
    lon2=a[2]
    lat2=a[3]
    lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])
    dlon = lon2 - lon1 
    dlat = lat2 - lat1 
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c =  2 * asin(sqrt(a)) 
    km = 6371* c
    return km
data['distance']=data[['pickup_longitude','pickup_latitude','dropoff_longitude',
                       'dropoff_latitude']].apply(distance,axis=1)
print(data["distance"].head(100))
data[data.distance==0].shape 
print(data.shape)
data.drop(data[data.distance==0].index,axis=0, inplace=True) 
print(data.shape)
import matplotlib.pyplot as plt
plt.bar(data['distance'],data['fare_amount'],label="Distance",color='b')
plt.xlabel('Distance')
plt.ylabel('Fare')
plt.show()

"""PREDICT:"""

import matplotlib
n_neighbors=6
from sklearn.model_selection import train_test_split 
from sklearn import preprocessing
from sklearn import metrics
from mpl_toolkits import mplot3d
x=data[['distance','night_hour','peak_hour']]
y=data['fare_amount']
X_train, X_test, y_train, y_test = train_test_split(x,y, test_size=0.3)
clf=neighbors.KNeighborsClassifier(n_neighbors,weights='distance')
lab_enc = preprocessing.LabelEncoder()
train_en = lab_enc.fit_transform(y_train)
print(X_train.shape)
print(y_train.shape)
clf.fit(X_train,train_en)
y_pred=clf.predict(X_test)
print(y_pred)
r =metrics.mean_squared_error(y_test,y_pred)
rmse=np.sqrt(r)
print('rmse:',rmse)
fig=plt.figure()
labels=['distance','night_hour','peak hour']
plt.plot(X_test,y_pred)
plt.legend(labels)
plt.xlabel('features')
plt.ylabel('predicted fare')
plt.show()
dist=input("enter distance")
import datetime
date=input('enter time and date')
date=pd.to_datetime(date, infer_datetime_format=True)
year=date.year
Month = date.month
Date = date.day
Day_of_Week = date.weekday()
Hour = date.hour
Minute = date.minute
night_hour = np.where((Hour >= 20) | (Hour <= 6) , 1, 0)
peak_hour = np.where(((Hour >= 16) & (Hour <= 20)) | ((Hour>=6) & (Hour<=9)) & ((Day_of_Week >=0) & (Day_of_Week <=4))  , 1, 0)
z=np.array([])
z=[]
z.append(dist)
z.append(night_hour) 
z.append(peak_hour)
z=np.array(z).reshape(1,-1)
y_pred=clf.predict(z)
print(y_pred)